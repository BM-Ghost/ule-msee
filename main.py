from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, validator
from typing import List, Optional
import uuid
import os
from datetime import datetime
import httpx
from dotenv import load_dotenv
import logging

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="AI Q&A API",
    description="API for AI-powered question answering using Groq",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],  # Add your frontend URLs
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models
class QuestionRequest(BaseModel):
    question: str = Field(..., min_length=1, max_length=2000, description="The question to ask the AI")
    
    @validator('question')
    def validate_question(cls, v):
        if not v.strip():
            raise ValueError('Question cannot be empty or just whitespace')
        return v.strip()

class QuestionResponse(BaseModel):
    response: str = Field(..., description="The AI's response to the question")

class HistoryItem(BaseModel):
    id: str = Field(..., description="Unique identifier for the history item")
    question: str = Field(..., description="The original question")
    response: str = Field(..., description="The AI's response")
    timestamp: str = Field(..., description="ISO timestamp when the question was asked")

class StatusResponse(BaseModel):
    status: str = Field(..., description="Status message")
    timestamp: str = Field(..., description="Current timestamp")

# In-memory storage for history (replace with database in production)
history_items: List[dict] = []

# Groq API client
class GroqClient:
    def __init__(self):
        self.api_key = os.getenv("GROQ_API_KEY")
        if not self.api_key:
            raise ValueError("GROQ_API_KEY environment variable is not set")
        
        self.base_url = "https://api.groq.com/openai/v1"
        self.model = "llama3-70b-8192"  # Using Llama 3 70B model
        self.timeout = 30.0
        
        logger.info(f"Initialized Groq client with model: {self.model}")
    
    async def generate_response(self, question: str) -> str:
        """Generate a response using Groq AI"""
        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                payload = {
                    "model": self.model,
                    "messages": [
                        {
                            "role": "system", 
                            "content": "You are a helpful AI assistant that provides accurate, concise, and informative answers. Format your responses using markdown when appropriate for better readability."
                        },
                        {
                            "role": "user", 
                            "content": question
                        }
                    ],
                    "temperature": 0.7,
                    "max_tokens": 1500,
                    "top_p": 0.9,
                    "stream": False
                }
                
                logger.info(f"Sending request to Groq API for question: {question[:50]}...")
                
                response = await client.post(
                    f"{self.base_url}/chat/completions",
                    headers={
                        "Authorization": f"Bearer {self.api_key}",
                        "Content-Type": "application/json"
                    },
                    json=payload
                )
                
                if response.status_code != 200:
                    error_detail = f"Groq API error: {response.status_code}"
                    try:
                        error_data = response.json()
                        error_detail += f" - {error_data.get('error', {}).get('message', 'Unknown error')}"
                    except:
                        error_detail += f" - {response.text}"
                    
                    logger.error(error_detail)
                    raise HTTPException(status_code=response.status_code, detail=error_detail)
                
                data = response.json()
                
                if not data.get("choices") or len(data["choices"]) == 0:
                    raise HTTPException(status_code=500, detail="No response generated by AI")
                
                ai_response = data["choices"][0]["message"]["content"]
                logger.info(f"Successfully generated response of length: {len(ai_response)}")
                
                return ai_response
                
        except httpx.TimeoutException:
            logger.error("Timeout while calling Groq API")
            raise HTTPException(status_code=504, detail="AI service timeout. Please try again.")
        except httpx.RequestError as e:
            logger.error(f"Request error while calling Groq API: {e}")
            raise HTTPException(status_code=503, detail="Unable to connect to AI service")
        except Exception as e:
            logger.error(f"Unexpected error in generate_response: {e}")
            raise HTTPException(status_code=500, detail="Internal server error while generating response")

# Dependency to get Groq client
def get_groq_client() -> GroqClient:
    try:
        return GroqClient()
    except ValueError as e:
        logger.error(f"Failed to initialize Groq client: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# API Routes
@app.get("/", response_model=StatusResponse)
async def root():
    """Root endpoint to check if the API is running"""
    return StatusResponse(
        status="AI Q&A API is running",
        timestamp=datetime.now().isoformat()
    )

@app.get("/health", response_model=StatusResponse)
async def health_check():
    """Health check endpoint"""
    return StatusResponse(
        status="healthy",
        timestamp=datetime.now().isoformat()
    )

@app.post("/api/question", response_model=QuestionResponse)
async def ask_question(
    request: QuestionRequest, 
    groq_client: GroqClient = Depends(get_groq_client)
):
    """Submit a question to the AI and get a response"""
    try:
        logger.info(f"Received question: {request.question[:100]}...")
        
        # Generate AI response
        response_text = await groq_client.generate_response(request.question)
        
        # Save to history
        history_item = {
            "id": str(uuid.uuid4()),
            "question": request.question,
            "response": response_text,
            "timestamp": datetime.now().isoformat()
        }
        
        history_items.append(history_item)
        
        # Keep only the last 100 items to prevent memory issues
        if len(history_items) > 100:
            history_items.pop(0)
        
        logger.info(f"Successfully processed question, history now has {len(history_items)} items")
        
        return QuestionResponse(response=response_text)
        
    except HTTPException:
        # Re-raise HTTP exceptions as-is
        raise
    except Exception as e:
        logger.error(f"Unexpected error in ask_question: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.get("/api/history", response_model=List[HistoryItem])
async def get_history():
    """Get the question and answer history"""
    try:
        # Return history sorted by timestamp (newest first)
        sorted_history = sorted(
            history_items, 
            key=lambda x: x["timestamp"], 
            reverse=True
        )
        
        logger.info(f"Returning {len(sorted_history)} history items")
        return sorted_history
        
    except Exception as e:
        logger.error(f"Error in get_history: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve history")

@app.delete("/api/history/{item_id}", response_model=StatusResponse)
async def delete_history_item(item_id: str):
    """Delete a specific history item"""
    try:
        global history_items
        original_length = len(history_items)
        
        history_items = [item for item in history_items if item["id"] != item_id]
        
        if len(history_items) == original_length:
            logger.warning(f"History item not found: {item_id}")
            raise HTTPException(status_code=404, detail="History item not found")
        
        logger.info(f"Deleted history item: {item_id}")
        return StatusResponse(
            status="History item deleted successfully",
            timestamp=datetime.now().isoformat()
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in delete_history_item: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete history item")

@app.delete("/api/history", response_model=StatusResponse)
async def clear_history():
    """Clear all history"""
    try:
        global history_items
        items_count = len(history_items)
        history_items = []
        
        logger.info(f"Cleared {items_count} history items")
        return StatusResponse(
            status=f"History cleared successfully ({items_count} items removed)",
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error in clear_history: {e}")
        raise HTTPException(status_code=500, detail="Failed to clear history")

# Error handlers
@app.exception_handler(404)
async def not_found_handler(request, exc):
    return {"detail": "Endpoint not found"}

@app.exception_handler(500)
async def internal_error_handler(request, exc):
    logger.error(f"Internal server error: {exc}")
    return {"detail": "Internal server error"}

if __name__ == "__main__":
    import uvicorn
    
    # Get port from environment or default to 8000
    port = int(os.getenv("PORT", 8000))
    
    logger.info(f"Starting server on port {port}")
    uvicorn.run(
        "main:app", 
        host="0.0.0.0", 
        port=port, 
        reload=True,
        log_level="info"
    )
